name: Keep Render Alive

on:
  schedule:
    # Run every 10 minutes (Render free tier sleeps after ~15 minutes of inactivity)
    - cron: '*/10 * * * *'
  workflow_dispatch: # Allow manual triggering

jobs:
  keep-alive:
    runs-on: ubuntu-latest
    timeout-minutes: 5 # Prevent hanging jobs

    steps:
    - name: Ping Render Service
      run: |
        echo "üåê Pinging Render service to keep it alive..."
        TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S UTC')
        
        # Function to ping with retries
        ping_service() {
          local max_retries=3
          local retry_count=0
          local success=false
          
          while [ $retry_count -lt $max_retries ] && [ "$success" = false ]; do
            echo "üîÑ Attempt $((retry_count + 1)) of $max_retries..."
            
            # Make the request with better timeout handling
            RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code};TIME:%{time_total};SIZE:%{size_download}" \
              --max-time 30 \
              --connect-timeout 10 \
              --retry 2 \
              --retry-delay 5 \
              --retry-max-time 60 \
              "https://shaadi-mantrana.onrender.com/health" 2>/dev/null)
            
            # Check if curl was successful
            if [ $? -eq 0 ]; then
              # Extract status and response time
              HTTP_STATUS=$(echo "$RESPONSE" | tr -d '\n' | sed -e 's/.*HTTPSTATUS://' | sed -e 's/;TIME.*//')
              RESPONSE_TIME=$(echo "$RESPONSE" | tr -d '\n' | sed -e 's/.*TIME://' | sed -e 's/;SIZE.*//')
              RESPONSE_SIZE=$(echo "$RESPONSE" | tr -d '\n' | sed -e 's/.*SIZE://')
              
              if [ "$HTTP_STATUS" = "200" ]; then
                echo "‚úÖ [$TIMESTAMP] Render service is awake (HTTP $HTTP_STATUS, ${RESPONSE_TIME}s, ${RESPONSE_SIZE} bytes)"
                success=true
                break
              else
                echo "‚ö†Ô∏è  [$TIMESTAMP] HTTP $HTTP_STATUS received (${RESPONSE_TIME}s)"
              fi
            else
              echo "‚ö†Ô∏è  [$TIMESTAMP] Curl failed with exit code $?"
            fi
            
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $max_retries ]; then
              echo "‚è≥ Waiting 10 seconds before retry..."
              sleep 10
            fi
          done
          
          if [ "$success" = false ]; then
            echo "‚ùå [$TIMESTAMP] All retry attempts failed"
            return 1
          fi
          
          return 0
        }
        
        # Execute the ping function
        if ping_service; then
          echo "üéâ Service ping successful!"
        else
          echo "üí• Service ping failed after all retries"
          exit 1
        fi

    - name: Notify on Failure
      if: failure()
      run: |
        echo "üö® Render service appears to be down or unresponsive"
        echo "üìä Job details:"
        echo "  - Workflow: ${{ github.workflow }}"
        echo "  - Run ID: ${{ github.run_id }}"
        echo "  - Commit: ${{ github.sha }}"
        echo "  - Branch: ${{ github.ref_name }}"
        echo "  - Triggered by: ${{ github.event_name }}"
        echo "  - Timestamp: $(date '+%Y-%m-%d %H:%M:%S UTC')"
        
        # You could add notification logic here (Slack, Discord, email, etc.)
        # Example for Slack webhook:
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"üö® Render service appears to be down! Check workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}
